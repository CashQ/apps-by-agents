name: AI App Contribution Validator

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]
  push:
    branches-ignore:
      - main
  schedule:
    # Run every hour to check for inactive PRs
    - cron: '0 * * * *'

# Permissions needed to comment on PRs
permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  validate-contribution:
    runs-on: ubuntu-latest
    if: github.event_name != 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Check branch naming convention
        id: check_branch
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "Checking branch name: $BRANCH_NAME"
          
          # Check if the branch follows the pattern month-year/username/app-name
          # For example: may-2025/xpander-ai/portfolio-app
          if ! [[ $BRANCH_NAME =~ ^[a-z]+-[0-9]{4}/[^/]+/[^/]+$ ]]; then
            echo "VALIDATION_FAILED=true" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=❌ Branch naming doesn't follow the pattern month-year/username/app-name (Example: may-2025/xpander-ai/portfolio-app)" >> $GITHUB_ENV
            exit 1
          fi
          
          # Extract parts from branch name
          DATE=$(echo $BRANCH_NAME | cut -d'/' -f1)
          USERNAME=$(echo $BRANCH_NAME | cut -d'/' -f2)
          APP_NAME=$(echo $BRANCH_NAME | cut -d'/' -f3)
          
          echo "DATE=$DATE" >> $GITHUB_ENV
          echo "USERNAME=$USERNAME" >> $GITHUB_ENV
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          
          echo "Date: $DATE"
          echo "Username: $USERNAME"
          echo "App name: $APP_NAME"
        continue-on-error: true
        
      - name: Validate directory structure and content
        id: validate_content
        if: ${{ !env.VALIDATION_FAILED && github.event_name == 'pull_request' }}
        run: |
          # Check if the correct directory structure exists
          if [ ! -d "${{ env.DATE }}/${{ env.USERNAME }}/${{ env.APP_NAME }}" ]; then
            echo "VALIDATION_FAILED=true" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=❌ Directory structure does not match the branch name. Expected: ${{ env.DATE }}/${{ env.USERNAME }}/${{ env.APP_NAME }}" >> $GITHUB_ENV
            exit 1
          fi
          
          # Check if README.md exists
          if [ ! -f "${{ env.DATE }}/${{ env.USERNAME }}/${{ env.APP_NAME }}/README.md" ]; then
            echo "VALIDATION_FAILED=true" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=❌ README.md is missing from the project directory" >> $GITHUB_ENV
            exit 1
          fi
          
          # Check if README mentions it was created by an AI
          if ! grep -q -i "AI\|agent\|generated\|created" "${{ env.DATE }}/${{ env.USERNAME }}/${{ env.APP_NAME }}/README.md"; then
            echo "VALIDATION_FAILED=true" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=❌ README.md should acknowledge that the application was created by an AI agent" >> $GITHUB_ENV
            exit 1
          fi
          
          # Combined check for AI Stack information - instead of multiple separate checks
          README_FILE="${{ env.DATE }}/${{ env.USERNAME }}/${{ env.APP_NAME }}/README.md"
          MISSING_SECTIONS=""
          
          # Check AI Stack section exists
          if ! grep -q -i "## AI Stack" "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- AI Stack section"
          fi
          
          # Check Type section
          if ! grep -q -i "### Type" "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- Type section (single-agent or multi-agent)"
          fi
          
          # Check Agent Card section
          if ! grep -q -i "### Agent Card" "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- Agent Card section"
          elif ! grep -q -i '```json.*"name".*"skills"' "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- Agent Card JSON format with name and skills fields"
          fi
          
          # Check Models section
          if ! grep -q -i "### Models" "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- Models section"
          fi
          
          # Check Framework section
          if ! grep -q -i "### AI Framework" "$README_FILE" && ! grep -q -i "framework" "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- AI Framework section"
          fi
          
          # Check Platform section
          if ! grep -q -i "### AI Platform" "$README_FILE" && ! grep -q -i "platform\|xpander\|self-hosted" "$README_FILE"; then
            MISSING_SECTIONS="$MISSING_SECTIONS\n- AI Platform section"
          fi
          
          # If any required sections are missing, fail validation
          if [ ! -z "$MISSING_SECTIONS" ]; then
            echo "VALIDATION_FAILED=true" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=❌ README.md is missing the following required sections:$MISSING_SECTIONS\n\nPlease check the README.md template for formatting guidelines." >> $GITHUB_ENV
            exit 1
          fi
          
          # Get list of files changed in this PR
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          
          # Check that all changed files are within the expected directory
          EXPECTED_PREFIX="${{ env.DATE }}/${{ env.USERNAME }}/${{ env.APP_NAME }}"
          
          # There can be some root files allowed to be modified (README, etc)
          ALLOWED_ROOT_FILES=("README.md" ".gitignore")
          
          INVALID_CHANGES=false
          INVALID_FILES=""
          
          for FILE in $CHANGED_FILES; do
            # Check if file starts with the expected prefix
            if [[ ! $FILE =~ ^$EXPECTED_PREFIX ]]; then
              # Check if it's an allowed root file
              IS_ALLOWED=false
              for ALLOWED_FILE in "${ALLOWED_ROOT_FILES[@]}"; do
                if [[ $FILE == $ALLOWED_FILE ]]; then
                  IS_ALLOWED=true
                  break
                fi
              done
              
              if [[ $IS_ALLOWED == false ]]; then
                echo "File '$FILE' is outside expected directory '$EXPECTED_PREFIX/'"
                INVALID_CHANGES=true
                INVALID_FILES="$INVALID_FILES\n- $FILE"
              fi
            fi
          done
          
          if [[ $INVALID_CHANGES == true ]]; then
            echo "VALIDATION_FAILED=true" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=❌ PR contains changes outside the expected directory '$EXPECTED_PREFIX/'! All changes must be within your app directory. Invalid files:$INVALID_FILES" >> $GITHUB_ENV
            exit 1
          else
            echo "✅ All changes are within expected directory: $EXPECTED_PREFIX/"
          fi
        continue-on-error: true
      
      - name: Post validation results as PR comment
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const validationFailed = process.env.VALIDATION_FAILED === 'true';
            const errorMessage = process.env.ERROR_MESSAGE || '';
            const branchName = process.env.BRANCH_NAME || '';
            
            let body = '';
            
            if (validationFailed) {
              body = `## ❌ Validation Failed\n\n${errorMessage}\n\n### How to Fix\n- Check out the [example app README](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/may-2025/xpander-ai/portfolio-app/README.md) for the correct format\n- Review the [CONTRIBUTING.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/CONTRIBUTING.md) guidelines\n\nPlease fix these issues and push a new commit to the PR.`;
              core.setFailed(errorMessage);
            } else {
              body = `## ✅ Validation Successful\n\nYour AI-generated app submission in branch \`${branchName}\` looks good and follows our repository guidelines. Great job!\n\n### Next Steps\n- Your PR will be reviewed by the repository maintainers\n- Please respond to any questions or comments\n- PRs that are inactive for more than 48 hours will be auto-closed`;
            }
            
            // Get existing comments to avoid duplicates
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            // Find our bot's validation comments
            const botComments = comments.filter(comment => 
              comment.user.type === 'Bot' && 
              (comment.body.includes('Validation Failed') || comment.body.includes('Validation Successful'))
            );
            
            // If there's a previous validation comment, update it
            if (botComments.length > 0) {
              const commentId = botComments[0].id;
              await github.rest.issues.updateComment({
                comment_id: commentId,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            } else {
              // Create a new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

  # Job to auto-close inactive PRs
  close-inactive-prs:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - name: Check and close inactive PRs
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get all open PRs
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            // Current time
            const now = new Date();
            
            for (const pr of pulls) {
              // Get PR activity (comments, commits, etc.)
              const prNumber = pr.number;
              
              // Get the latest commit
              const { data: commits } = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Get the latest comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              // Find the latest activity time
              let latestActivityTime = new Date(pr.updated_at);
              
              if (commits.length > 0) {
                const latestCommitTime = new Date(commits[commits.length - 1].commit.committer.date);
                if (latestCommitTime > latestActivityTime) {
                  latestActivityTime = latestCommitTime;
                }
              }
              
              if (comments.length > 0) {
                const latestCommentTime = new Date(comments[comments.length - 1].created_at);
                if (latestCommentTime > latestActivityTime) {
                  latestActivityTime = latestCommentTime;
                }
              }
              
              // Check if PR has been inactive for more than 48 hours
              const hoursSinceLastActivity = (now - latestActivityTime) / (1000 * 60 * 60);
              
              if (hoursSinceLastActivity >= 48) {
                console.log(`PR #${prNumber} has been inactive for ${Math.floor(hoursSinceLastActivity)} hours. Closing.`);
                
                // Add closing comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## ⏱️ PR Auto-Closed\n\nThis PR has been inactive for more than 48 hours and is being automatically closed.\n\nIf you would like to continue working on this submission, please create a new PR.`
                });
                
                // Close PR
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  state: 'closed'
                });
              } else {
                console.log(`PR #${prNumber} has been active in the last 48 hours (${Math.floor(hoursSinceLastActivity)} hours ago). Keeping open.`);
              }
            } 